#!/usr/bin/env python

import os, re, string, sys, argparse, signal
pidp = None

def version():
    print "Generic Colouriser 1.4"
    sys.exit()

def help():
    print "Generic Colouriser 1.4"
    print
    print "grc [options] command [args]"
    print
    print "Options:"
    print "-e --stderr    redirect stderr. If this option is selected, "
    print "               do not automatically redirect stdout"
    print "-s --stdout    redirect stdout, even if -e is selected"
    print "-c name --config=name    use name as configuration file for grcat"
    print "--colour=word  word is one of: on, off, auto"
    print
    sys.exit()


def keybint(signum, frame):
    global pidp
    try:
        os.kill(pidp, signal.SIGINT)
    except OSError: # if the subprocess already died
        pass

def create( args ):

    command = args.command.lower()

    HOME = os.environ['HOME']
    ZSHOME = os.environ['ZSHOME']
    
    conf_file = HOME + "/.grc/conf.%s" % ( command )

    if os.path.isfile( conf_file ):
        sys.stdout.write( "It would seem that a GRC configuration already exists for '%s'...\n" % command )
        sys.exit()

    # Create the configuration file
    conf_file = open( conf_file, 'a' )
    conf_file.write( "# GRC CONFIGURATION FOR %s\n" % ( command.upper() ) )
    conf_file.write( "regexp=%s\n" % ( args.color_regexp or '' )  )
    conf_file.write( "colours=%s\n" % args.colors or '' )
    conf_file.close()

    # Edit the grc.conf file
    grc_conf = HOME + "/.grc/grc.conf"
    grc_conf = open( grc_conf, 'a' )
    grc_conf.write( "\n# %s command\n" % command )
    grc_conf.write( args.command_regexp % command )
    grc_conf.write( "\nconf.%s\n" % command )
    grc_conf.close()

    # Edit the grc.zsh file
    grc_zsh = ZSHOME + "/system/grc.zsh"
    grc_zsh = open( grc_zsh, 'r+w' )
    alias = "    alias %s='colorify %s'\n" % ( command, command )
    lines = grc_zsh.readlines()
    # Hacky way to clear the file so we don't get repeats
    grc_zsh.seek(0)
    grc_zsh.truncate()
    lines.insert( -1, alias )
    grc_zsh.writelines( lines )
    grc_zsh.close()

    sys.stdout.write( "Successfully created templates for %s!\n" % command )
    sys.exit()

def delete( args ):

    command = args.command.lower()

    HOME = os.environ['HOME']
    ZSHOME = os.environ['ZSHOME']

    conf_file = HOME + "/.grc/conf.%s" % ( command )
    if not os.path.isfile( conf_file ):
        sys.stdout.write( "It would appear that '%s' is not yet configured by GRC...\n" % command )
        sys.exit()

    # Delete the GRC configuration file
    os.remove( conf_file )

    # Remove it from the grc.conf file
    grc_conf = HOME + "/.grc/grc.conf"
    grc_conf = open( grc_conf, 'r+w' )
    lines = grc_conf.readlines()
    grc_conf.seek(0)
    grc_conf.truncate()
    lines = [lines[i:i+3] for i in range( 0, len( lines ), 4 )]
    removable = "%s\n" % os.path.basename( conf_file )
    lines.remove( filter( lambda x: removable in x, lines )[0] )
    lines = [group for sublist in lines for group in sublist + ['\n']]
    # Don't need the last newline
    lines = lines[0:-1]
    grc_conf.writelines( lines )
    grc_conf.close()

    # Remove it from the grc.zsh file
    grc_zsh = ZSHOME + "/system/grc.zsh"
    grc_zsh = open( grc_zsh, 'r+w' )
    removable = "    alias %s='colorify %s'\n" % ( command, command )
    lines = grc_zsh.readlines()
    grc_zsh.seek(0)
    grc_zsh.truncate()
    lines.remove( removable )
    grc_zsh.writelines( lines )
    grc_zsh.close()

    sys.stdout.write( "Successfully deleted %s!\n" % command )
    sys.exit()

def colorify( args ):

    global pidp

    stdoutf = args.stdout
    stderrf = args.stderr

    # configure file for grcat
    cfile = args.config

    if args.color == "on":
        color = True
    elif args.color == "off":
        color = False
    else:
        color = sys.stdout.isatty()

    stdoutff = 1
    stderrff = 0
    if stderrf:
        stdoutff = 0
        stderrff = 1
    if stdoutf:
        stdoutff = 1

    conffile = None
    if not cfile:
        home = []
        if os.environ.has_key('HOME'):
            home = [os.environ['HOME']+"/.grc/grc.conf"]
        conffilenames = home + ["/usr/local/etc/grc.conf"]
        for i in conffilenames:
            if os.path.isfile(i):
                conffile = i
                break
        regexplist = []

        if conffile:
            f = open(conffile, "r")
            while 1:
                l = f.readline()
                if l == "":
                    break
                if l[0] == "#" or l[0] == '\012':
                    continue
                regexp = l[:-1]
                if re.search(regexp, string.join(args.commands)):
                    cfile = f.readline()[:-1]
                    break

    signal.signal(signal.SIGINT, keybint)

    if cfile and color:
        if stdoutff:
            choo, chio = os.pipe()
        if stderrff:
            choe, chie = os.pipe()


        pidp = os.fork()
        if pidp == 0: # child
            if stdoutff:
                os.dup2(chio, 1)
                os.close(choo)
                os.close(chio)
            if stderrff:
                os.dup2(chie, 2)
                os.close(choe)
                os.close(chie)
            os.execvp(args.commands[0], args.commands)


        if stdoutff:
            pido = os.fork()
            if pido == 0: # child
                os.dup2(choo, 0)
                os.close(choo)
                os.close(chio)
                if stderrff:
                    os.close(choe)
                    os.close(chie)
                os.execvp("grcat", ["grcat", cfile])

        if stderrff:
            pide = os.fork()
            if pide == 0: # child
                os.dup2(choe, 0)
                os.dup2(2, 1)
                os.close(choe)
                os.close(chie)
                if stdoutff:
                    os.close(choo)
                    os.close(chio)
                os.execvp("grcat", ["grcat", cfile])

        try:
            status = os.waitpid(pidp, 0)[1]
        except OSError: # interrupted system call
            status = None
            pass # this is probably not correct
        if stderrff:
            os.close(chie)
            os.waitpid(pide, 0)
            os.close(choe)
        if stdoutff:
            os.close(chio)
            os.waitpid(pido, 0)
            os.close(choo)
        sys.exit(status and os.WEXITSTATUS(status))

    else:
        pidp = os.fork() 
        if pidp == 0:
            os.execvp(args.name, args.commands)
        try:
            status = os.wait()[1]
        except OSError: # interrupted system call
            status = None
            pass # this is probably not correct

    sys.exit(status and os.WEXITSTATUS(status))

parser = argparse.ArgumentParser( description="Colorize your terminal (and your life)" )
subparsers = parser.add_subparsers( dest="name", help='COMMAND-SPECIFIC HELP' )

# Parser for `create`
create_parser = subparsers.add_parser( 'create', help="Add a new terminal command to GRC" )
create_parser.add_argument(
    'command',
    metavar='COMMAND',
    help="Command you want to create"
    )
create_parser.add_argument(
    '--color-regexp',
    '-l',
    type=str,
    default=None,
    help="Regular expression for color-matching"
    )
create_parser.add_argument(
    '--command-regexp',
    '-m',
    type=str,
    default=r"(^|[/\w\.]+/)%s\s?",
    help="Regular expression for command-matching"
    )
create_parser.add_argument(
    '-c',
    '--colors',
    type=str,
    default=None,
    help="Colors for the command-colorizing"
    )
create_parser.set_defaults( func=create )

# Parser for `delete`
delete_parser = subparsers.add_parser( 'delete', help="Remove a terminal command from GRC" )
delete_parser.set_defaults( func=delete )
delete_parser.add_argument(
    'command',
    metavar="COMMAND",
    help="Command you want to delete"
    )

# Default parser
run_parser = subparsers.add_parser( 'colorify', help="Run a configured command through GRC" )
run_parser.add_argument(
    'commands',
    metavar="COMMANDS",
    nargs="+",
    help="Terminal commands to run"
    )
run_parser.add_argument(
    '-e',
    '--stderr',
    action="store_true",
    help="Redirect STDERR.  If this option is selected, do not automatically redirect STDOUT"
    )
run_parser.add_argument(
    '-s',
    '--stdout',
    action="store_true",
    help="Redirect STDOUT, even if -e is selected"
    )
run_parser.add_argument(
    '-c',
    '--config',
    default=None,
    type=str,
    metavar="CFILE",
    help="Use CFILE as configuration file for grcat"
    )
run_parser.add_argument(
    '--color',
    default="auto",
    type=str,
    choices = ["on", "off", "auto"],
    help="Choose how to colorize the output"
    )
run_parser.set_defaults( func=colorify )

args, unknown = parser.parse_known_args()
if 'commands' in vars(args): args.commands.extend( unknown )
args.func( args )
